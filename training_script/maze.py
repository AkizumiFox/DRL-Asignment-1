import random
import math

class Maze:
    def __init__(self, n):
        """
        Initialize the maze of size (n+2) x (n+2) including a border of walls.
        The interior maze is generated by randomly placing floor(0.05 * n * n) walls.
        The generation is repeated until the interior blank cells are all connected.
        """
        self.n = n
        self.size = n + 2
        self.maze = [['#' for _ in range(self.size)] for _ in range(self.size)]

        # Two sets for storing coordinates of walls and blanks
        self.wall_coords = set()
        self.blank_coords = set()

        # List to store the station coordinates
        self.stations = []

        # Lists to store taxi and passenger information
        self.taxi_location = []
        self.pass_idx = None  # Station index (0-3) for passenger location
        self.dest_idx = None  # Station index (0-3) for destination
        self.passenger_loc = None  # Actual coordinates of passenger location
        self.destination = None  # Actual coordinates of destination
        self.passenger_picked_up = False  # Track if passenger is in taxi
        self.fuel = 5000  # Initialize fuel

        # Generate the maze on initialization using the new algorithm
        self._generate_maze()

        # Fill in the wall_coords and blank_coords sets based on the final maze
        self._populate_coordinate_sets()

        # Select the stations ensuring they are not adjacent
        self._select_stations()

        # Select taxi location and passenger information
        self._select_taxi_and_passenger()

    def _generate_maze(self):
        """
        Generate a maze by randomly placing floor(0.05 * n * n) walls in the interior.
        Repeats until the interior blank cells (ignoring boundary walls) are fully connected.
        """
        count_walls = math.floor(0.1 * self.n * self.n)
        while True:
            # Reset maze with boundary walls and interior blanks.
            self.maze = [['#' for _ in range(self.size)] for _ in range(self.size)]
            for r in range(1, self.n + 1):
                for c in range(1, self.n + 1):
                    self.maze[r][c] = ' '
            
            # Randomly place the walls in the interior.
            interior_coords = [(r, c) for r in range(1, self.n + 1) for c in range(1, self.n + 1)]
            wall_cells = random.sample(interior_coords, count_walls)
            for (r, c) in wall_cells:
                self.maze[r][c] = '#'
            
            # Check if the interior blank cells are all connected.
            if self._is_connected():
                break

    def _is_connected(self):
        """
        Check if all blank cells in the interior (ignoring the boundary walls) are connected.
        Returns True if connected, False otherwise.
        """
        visited = set()
        start = None
        # Find a starting blank cell in the interior.
        for r in range(1, self.n + 1):
            for c in range(1, self.n + 1):
                if self.maze[r][c] == ' ':
                    start = (r, c)
                    break
            if start is not None:
                break

        if start is None:
            return False  # No blank cell available.
        
        # Flood fill (using DFS) to traverse connected blank cells.
        stack = [start]
        while stack:
            (r, c) = stack.pop()
            if (r, c) in visited:
                continue
            visited.add((r, c))
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                if 1 <= nr <= self.n and 1 <= nc <= self.n and self.maze[nr][nc] == ' ' and (nr, nc) not in visited:
                    stack.append((nr, nc))
        
        # Count the total number of blank cells in the interior.
        total_blank = sum(1 for r in range(1, self.n + 1) for c in range(1, self.n + 1) if self.maze[r][c] == ' ')
        return len(visited) == total_blank

    def _populate_coordinate_sets(self):
        """
        Populate wall_coords and blank_coords based on the final layout in self.maze.
        """
        self.wall_coords.clear()
        self.blank_coords.clear()
        for r in range(self.size):
            for c in range(self.size):
                if self.maze[r][c] == '#':
                    self.wall_coords.add((r, c))
                else:
                    self.blank_coords.add((r, c))

    def _select_stations(self):
        """
        Randomly selects 4 blank cells to serve as stations, ensuring that
        no two stations are adjacent (cardinally). Repeats the selection until valid.
        """
        while True:
            blank_list = list(self.blank_coords)
            if len(blank_list) < 4:
                # If there aren't enough blanks, assign whatever is available.
                self.stations = [list(coord) for coord in blank_list]
                break
            selected_coords = random.sample(blank_list, 4)
            
            # Check that no two selected stations are adjacent (Manhattan distance == 1).
            valid = True
            for i in range(len(selected_coords)):
                for j in range(i + 1, len(selected_coords)):
                    r1, c1 = selected_coords[i]
                    r2, c2 = selected_coords[j]
                    if abs(r1 - r2) + abs(c1 - c2) == 1:
                        valid = False
                        break
                if not valid:
                    break
            if valid:
                self.stations = [list(coord) for coord in selected_coords]
                break

    def _select_taxi_and_passenger(self):
        """
        Randomly selects a blank cell for the taxi (not a station).
        Randomly selects two different stations for passenger location and destination.
        """
        station_coords = {tuple(station) for station in self.stations}
        available_coords = list(self.blank_coords - station_coords)
        
        if available_coords:
            taxi_coord = random.choice(available_coords)
            self.taxi_location = list(taxi_coord)
        else:
            self.taxi_location = []

        if len(self.stations) >= 2:
            station_indices = list(range(len(self.stations)))
            selected_indices = random.sample(station_indices, 2)
            self.pass_idx = selected_indices[0]
            self.dest_idx = selected_indices[1]
            self.passenger_loc = self.stations[self.pass_idx]
            self.destination = self.stations[self.dest_idx]
        else:
            self.pass_idx = None
            self.dest_idx = None
            self.passenger_loc = None
            self.destination = None

    def step(self, action):
        """
        Execute an action and update the environment state.

        Args:
            action (int):
                0: Move south
                1: Move north
                2: Move east
                3: Move west
                4: Pick up passenger
                5: Drop off passenger

        Returns:
            tuple: (observation, reward, done, False, False)
        """
        reward = -0.1  # Each step costs -0.1
        self.fuel -= 1

        if self.fuel <= 0:
            return self.get_state(), reward - 10, True, False, False  # Fuel exhaustion penalty

        if 0 <= action <= 3:
            directions = [(1, 0),  (-1, 0), (0, 1), (0, -1)]
            dr, dc = directions[action]
            new_r, new_c = self.taxi_location[0] + dr, self.taxi_location[1] + dc

            if (new_r, new_c) in self.wall_coords:
                reward -= 5  # Penalty for hitting a wall
                return self.get_state(), reward, False, False, False

            self.taxi_location = [new_r, new_c]

        elif action == 4:  # Pick up passenger
            if not self.passenger_picked_up and self.taxi_location == self.passenger_loc:
                self.passenger_picked_up = True
            else:
                reward -= 10  # Penalty for incorrect pickup

        elif action == 5:  # Drop off passenger
            if self.passenger_picked_up and self.taxi_location == self.destination:
                self.passenger_picked_up = False
                reward += 50  # Reward for successful delivery
                return self.get_state(), reward, True, False, False  # Set done to True on successful drop-off
            else:
                reward -= 10  # Penalty for incorrect dropoff

        return self.get_state(), reward, False, False, False

    def _randomize_passenger_and_destination(self):
        """
        Randomly selects new passenger and destination stations (they must be different).
        """
        if len(self.stations) >= 2:
            station_indices = list(range(len(self.stations)))
            selected_indices = random.sample(station_indices, 2)
            self.pass_idx = selected_indices[0]
            self.dest_idx = selected_indices[1]
            self.passenger_loc = self.stations[self.pass_idx]
            self.destination = self.stations[self.dest_idx]
            self.passenger_picked_up = False

    def __str__(self):
        """
        Return a string representation of the maze for printing.
        """
        return "\n".join("".join(row) for row in self.maze)

    def get_state(self):
        """
        Returns the current state representation as a tuple containing:
        - Taxi position (adjusted by -1 to ignore the border)
        - Station coordinates (padded to ensure 4 stations, adjusted by -1)
        - Obstacle flags in the four cardinal directions
        - Passenger and destination visibility flags
        - Station direction flags (16 values: 4 per station for N, E, W, S)

        Returns:
            tuple: State representation
        """
        taxi_row, taxi_col = self.taxi_location
        obstacle_north = int((taxi_row - 1, taxi_col) in self.wall_coords)
        obstacle_south = int((taxi_row + 1, taxi_col) in self.wall_coords)
        obstacle_east  = int((taxi_row, taxi_col + 1) in self.wall_coords)
        obstacle_west  = int((taxi_row, taxi_col - 1) in self.wall_coords)

        padded_stations = self.stations + [[0, 0]] * (4 - len(self.stations))

        passenger_loc = self.passenger_loc
        passenger_loc_north = int(passenger_loc == [taxi_row - 1, taxi_col])
        passenger_loc_south = int(passenger_loc == [taxi_row + 1, taxi_col])
        passenger_loc_east  = int(passenger_loc == [taxi_row, taxi_col + 1])
        passenger_loc_west  = int(passenger_loc == [taxi_row, taxi_col - 1])
        passenger_loc_middle = int(passenger_loc == [taxi_row, taxi_col])
        passenger_look = (passenger_loc_north or passenger_loc_south or
                          passenger_loc_east or passenger_loc_west or passenger_loc_middle)

        destination = self.destination
        destination_loc_north = int(destination == [taxi_row - 1, taxi_col])
        destination_loc_south = int(destination == [taxi_row + 1, taxi_col])
        destination_loc_east  = int(destination == [taxi_row, taxi_col + 1])
        destination_loc_west  = int(destination == [taxi_row, taxi_col - 1])
        destination_loc_middle = int(destination == [taxi_row, taxi_col])
        destination_look = (destination_loc_north or destination_loc_south or
                            destination_loc_east or destination_loc_west or destination_loc_middle)

        state = (
            taxi_row - 1, taxi_col - 1,
            padded_stations[0][0] - 1, padded_stations[0][1] - 1,
            padded_stations[1][0] - 1, padded_stations[1][1] - 1,
            padded_stations[2][0] - 1, padded_stations[2][1] - 1,
            padded_stations[3][0] - 1, padded_stations[3][1] - 1,
            obstacle_west, obstacle_east, obstacle_south, obstacle_north,
            passenger_look, destination_look,
        )
        return state

def get_station_directions(obs):
    """
        tuple: 16 binary values where:
        - Values 0-3: Station 0's [North, East, West, South] position relative to taxi
        - Values 4-7: Station 1's [North, East, West, South] position relative to taxi
        - Values 8-11: Station 2's [North, East, West, South] position relative to taxi
        - Values 12-15: Station 3's [North, East, West, South] position relative to taxi
    """
    taxi_row, taxi_col = obs[0], obs[1]
    
    stations = [
        (obs[2], obs[3]),
        (obs[4], obs[5]),
        (obs[6], obs[7]),
        (obs[8], obs[9])
    ]
    
    station_directions = []
    for station in stations:
        station_row, station_col = station
        station_directions.append(int(station_col > taxi_col))
        station_directions.append(int(station_col < taxi_col))
        station_directions.append(int(station_row > taxi_row))
        station_directions.append(int(station_row < taxi_row))
    
    return tuple(station_directions)

def passenger_on_taxi(prev_state, action, now_state, prev):
    stations_1 = [[0, 0] for _ in range(4)]
    (
        taxi_row_1, taxi_col_1,
        stations_1[0][0], stations_1[0][1],
        stations_1[1][0], stations_1[1][1],
        stations_1[2][0], stations_1[2][1],
        stations_1[3][0], stations_1[3][1],
        _, _, _, _,
        passenger_look_1, destination_look_1
    ) = prev_state

    stations_2 = [[0, 0] for _ in range(4)]
    (
        taxi_row_2, taxi_col_2,
        stations_2[0][0], stations_2[0][1],
        stations_2[1][0], stations_2[1][1],
        stations_2[2][0], stations_2[2][1],
        stations_2[3][0], stations_2[3][1],
        _, _, _, _,
        passenger_look_2, destination_look_2
    ) = now_state

    if action == 5 and [taxi_row_2, taxi_col_2] in stations_2 and destination_look_2 == 1:
        return 0
    if action != 4:
        return prev
    if [taxi_row_2, taxi_col_2] in stations_2 and passenger_look_2 == 1:
        return 1
    return 0

def interactive_test(maze_size=6):
    """
    Interactive testing function that allows manual control of the taxi.
    
    Args:
        maze_size (int): Size of the maze to generate
    """
    # Initialize maze
    maze_obj = Maze(maze_size)
    done = False
    total_reward = 0
    
    # Display the initial state
    clear_screen()
    display_state(maze_obj)
    
    # Main interaction loop
    while not done:
        # Get action from user
        action = get_user_action()
        
        if action == -1:
            print("Exiting interactive test...")
            break
            
        # Execute the action
        obs, reward, done, _, _ = maze_obj.step(action)
        total_reward += reward
        
        # Display the updated state
        clear_screen()
        display_state(maze_obj)
        display_observation(obs)
        
        # Show action result
        print(f"Action: {action_to_string(action)}")
        print(f"Reward: {reward:.1f}")
        print(f"Total Reward: {total_reward:.1f}")
        
        if done:
            if maze_obj.fuel <= 0:
                print("Game over! (Fuel depleted)")
            else:
                print("Game over! Passenger delivered successfully!")
            
        # Success message for pickup and dropoff
        if action == 4 and maze_obj.passenger_picked_up:
            print("Passenger picked up successfully!")
        elif action == 5 and not maze_obj.passenger_picked_up and reward > 0:
            print("Passenger delivered successfully!")

def clear_screen():
    """Clear the terminal screen."""
    print("\033[H\033[J", end="")  # ANSI escape sequence to clear screen

def action_to_string(action):
    """Convert action number to descriptive string with key mapping."""
    actions = {
        0: "Move South (S)",
        1: "Move North (W)", 
        2: "Move East (D)",
        3: "Move West (A)",
        4: "Pick up passenger (P)",
        5: "Drop off passenger (O)"
    }
    return actions.get(action, "Unknown")

def get_user_action():
    """Get action input from the user using keyboard-style controls."""
    print("\nAvailable actions:")
    print("W: Move North")
    print("A: Move West")
    print("S: Move South")
    print("D: Move East")
    print("P: Pick up passenger")
    print("O: Drop off passenger")
    print("Q: Quit")
    
    # Action mapping from keyboard controls to action numbers
    action_map = {
        'w': 1,  # North
        'a': 3,  # West
        's': 0,  # South
        'd': 2,  # East
        'p': 4,  # Pick up
        'o': 5,  # Drop off
    }
    
    while True:
        user_input = input("\nEnter action: ").strip().lower()
        
        if user_input == 'q':
            return -1
        elif user_input in action_map:
            return action_map[user_input]
        else:
            print("Invalid input. Please use W/A/S/D for movement, P to pick up, O to drop off, or Q to quit.")

def display_state(maze_obj):
    """Display the current state of the maze with taxi, passenger, and destination."""
    # Create a visual representation of the maze
    visual_maze = []
    for row in range(maze_obj.size):
        visual_row = []
        for col in range(maze_obj.size):
            if [row, col] == maze_obj.taxi_location:
                char = 'T'
            elif not maze_obj.passenger_picked_up and [row, col] == maze_obj.passenger_loc:
                char = 'P'
            elif [row, col] == maze_obj.destination:
                char = 'D'
            elif [row, col] in maze_obj.stations:
                char = 'S'
            else:
                char = maze_obj.maze[row][col]
            visual_row.append(char)
        visual_maze.append(visual_row)
    
    # Print the maze
    print("\nCurrent Maze:")
    print("-" * (maze_obj.size + 2))
    for row in visual_maze:
        print("|" + "".join(row) + "|")
    print("-" * (maze_obj.size + 2))
    
    # Print status information
    print(f"\nTaxi Location: {maze_obj.taxi_location}")
    print(f"Passenger Station: {maze_obj.pass_idx}")
    print(f"Destination Station: {maze_obj.dest_idx}")
    print(f"Passenger Picked Up: {'Yes' if maze_obj.passenger_picked_up else 'No'}")
    print(f"Fuel Remaining: {maze_obj.fuel}")

def display_observation(obs):
    """Display the observation tuple in a readable format."""
    if not obs:
        print("No observation available")
        return
        
    # Unpack the observation
    taxi_row, taxi_col = obs[0], obs[1]
    stations = [
        [obs[2], obs[3]],  # Station 0
        [obs[4], obs[5]],  # Station 1
        [obs[6], obs[7]],  # Station 2
        [obs[8], obs[9]]   # Station 3
    ]
    obstacle_west = obs[10]
    obstacle_east = obs[11]
    obstacle_south = obs[12]
    obstacle_north = obs[13]
    passenger_visible = obs[14]
    destination_visible = obs[15]
    
    # Calculate station directions directly rather than trying to read them from obs
    station_directions = []
    for station in stations:
        station_row, station_col = station
        directions = []
        if station_row < taxi_row: directions.append("North")
        if station_col > taxi_col: directions.append("East")
        if station_col < taxi_col: directions.append("West")
        if station_row > taxi_row: directions.append("South")
        station_directions.append(directions)
    
    # Print in a formatted way
    print("\nObservation Details:")
    print(f"  {obs}")
    directions = []
    if obstacle_north: directions.append("North")
    if obstacle_south: directions.append("South")
    if obstacle_east: directions.append("East")
    if obstacle_west: directions.append("West")
    print("  Obstacles in direction(s): " + (", ".join(directions) if directions else "None"))
    print(f"  Passenger visible: {'Yes' if passenger_visible else 'No'}")
    print(f"  Destination visible: {'Yes' if destination_visible else 'No'}")
    
    # Print station direction information
    print("\nStation Directions from Taxi:")
    for i in range(4):
        print(f"  Station {i}: {', '.join(station_directions[i]) or 'None'}")

def update_target(obs, old_target):
    if (obs[0], obs[1]) == (obs[2], obs[3]) and old_target == 0:
        return 1
    if (obs[0], obs[1]) == (obs[4], obs[5]) and old_target == 1:
        return 2
    if (obs[0], obs[1]) == (obs[6], obs[7]) and old_target == 2:
        return 3
    if (obs[0], obs[1]) == (obs[8], obs[9]) and old_target == 3:
        return 0
    return old_target

def reward_shaping(prev_obs, prev_target, action, now_obs, now_target, reward):
    """
    Applies potential-based reward shaping based on distance to current target.
    """
    def get_target_coords(obs, target_idx):
        if target_idx == 0: return obs[2], obs[3]
        elif target_idx == 1: return obs[4], obs[5]
        elif target_idx == 2: return obs[6], obs[7]
        elif target_idx == 3: return obs[8], obs[9]
    
    def manhattan_distance(row1, col1, row2, col2):
        return abs(row1 - row2) + abs(col1 - col2)

    if prev_target != now_target:
        return reward
    else:
        target_row, target_col = get_target_coords(now_obs, now_target)
        prev_potential = -manhattan_distance(prev_obs[0], prev_obs[1], target_row, target_col)
        next_potential = -manhattan_distance(now_obs[0], now_obs[1], target_row, target_col)
        shaping_reward = next_potential - prev_potential
        return reward + shaping_reward

if __name__ == "__main__":
    env = Maze(10)
    obs = env.get_state()
    station_directions = get_station_directions(obs)
    have_passenger = 0
    now_target = 0
    shaped_reward = 0

    done = False
    while not done:
        # Display the current maze state
        clear_screen()
        display_state(env)
        print(obs)
        
        state = list(station_directions) + list(obs[10:]) + [have_passenger] + [now_target]
        # print("Station Directions:")
        # print(f'    {state[0:4]}')
        # print(f'    {state[4:8]}')
        # print(f'    {state[8:12]}')
        # print(f'    {state[12:16]}')
        # print("Obstacles:")
        # print(f'    {state[16:20]}')
        # print("Passenger / Destination Near:")
        # print(f'    {state[20]}, {state[21]}')
        # print(f'Have Passenger: {state[22]}')
        # print(f'Now Target: {state[23]}')
        # print(f'Shaped Reward: {shaped_reward}')
        
        user_input = input("\nEnter action: ").strip().lower()
        if user_input == 'q': break
        # action_map = { 'w': 1, 'a': 3, 's': 0, 'd': 2, 'p': 4, 'o': 5 }
        action_map = {'0', '1', '2', '3', '4', '5'}
        if user_input in action_map:
            action = int(user_input)
        else:
            print("Invalid input! Use WASD for movement, P to pick up, O to drop off")
            continue

        next_obs, reward, done, _, _ = env.step(action)

        next_station_directions = get_station_directions(next_obs)
        next_have_passenger = passenger_on_taxi(obs, action, next_obs, have_passenger)
        next_now_target = update_target(next_obs, now_target)

        shaped_reward = reward_shaping(obs, now_target, action, next_obs, next_now_target, reward)

        obs = next_obs
        station_directions = next_station_directions
        have_passenger = next_have_passenger
        now_target = next_now_target